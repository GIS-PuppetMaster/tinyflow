## Capuchin的复现问题
1. [实现错误] capuchin非第一次运行触发被动调度时，论文中说明应将预取时间提前5%，代码实现有误，将时间推迟。——已经修复问题。
2. [实现错误] 由于对论文理解有误，没有正确实现collective recomputation。——已经参照作者在youtube上的讲解ppt进行了正确实现。
3. [对比标准有误] 用作对比的vanilla的优化器执行代码中不包含许多逻辑判断，与对应的Capuchin和vdnn执行器差异较大，这些额外的python逻辑引入了较大的时间开销。——使用屏蔽了相关调度逻辑的Capuchin和vdnn执行器分别作为计算二者MSR和CBR的标准，以达到公平对比算法本身性能，而忽略代码实现方式导致的性能差异的目的。
4. [论文未给出细节，调整实现方式以实现更高的执行速度] 论文伪代码中的变量mem_tosave未进行明确定义。——本次修改进行了调整，放宽了其约束，使得复现的capuchin算法倾向于节约更多的显存以避免被动swap in，显著减少了被动swap in导致的额外时间开销。
5. [论文未给出细节，调整实现方式以实现更高的执行速度] 对于如何获取swap_in_trigger，原文中没有给出细节，亦没有给出源代码。第一版复现代码中采用了比较严格的方式，在选择trigger时严格避免swap的重叠。——经过分析，由于PCIe通道的独占性质可以确保该点，于是本次修改放宽了此项限制。

## Capuchin目前的主要额外开销来源
1. 重计算时需要额外开辟计划外的显存空间，导致可能需要先逐出部分张量再重计算
2. 第一次被动模式时间开销较长